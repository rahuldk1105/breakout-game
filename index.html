<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Endless Breakout - Web</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #1a1a1a;
            font-family: Arial, sans-serif;
            color: white;
            overflow: hidden; /* Prevent scrollbars */
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px; /* Max width for larger screens */
            margin: auto;
            position: relative; /* Needed for absolute positioning of UI */
        }

        #gameCanvas {
            background-color: #000;
            display: block;
            max-width: 100%;
            border: 2px solid #444;
            box-sizing: border-box;
            touch-action: none; /* Prevent browser gestures like swipe-to-refresh */
        }

         #controls {
            display: flex;
            justify-content: space-between;
            width: 80%;
            max-width: 400px;
            margin-top: 15px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .control-button {
            background-color: #444;
            color: white;
            border: 2px solid #666;
            border-radius: 10px;
            padding: 15px 25px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            text-align: center;
            flex-grow: 1;
            margin: 0 10px;
            transition: background-color 0.1s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .control-button:active, .control-button.active {
             background-color: #666;
        }

        #ui-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 5px 10px;
            box-sizing: border-box;
            font-size: 16px;
            position: absolute;
            top: 10px;
            left: 0;
            pointer-events: none;
            z-index: 5;
        }
         #ui-info span {
             background-color: rgba(0,0,0,0.6);
             padding: 4px 8px;
             border-radius: 4px;
             margin: 0 5px;
         }
         #score { order: 1; margin-left: auto; }
         #level { order: 2; }
         #lives { order: 3; margin-right: auto;}


        .message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 10;
            font-size: 1.5em;
            box-sizing: border-box;
            padding: 20px;
            cursor: pointer; /* Make overlays clickable */
        }
        .message-overlay h2 {
            margin-bottom: 15px;
            pointer-events: none; /* Allow clicks to pass through text */
        }
        .message-overlay p {
            font-size: 0.7em;
            margin-top: 10px;
            line-height: 1.4;
            pointer-events: none; /* Allow clicks to pass through text */
        }


    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-info">
             <span id="lives">Lives: 3</span>
             <span id="level">Level: 0</span>
             <span id="score">Score: 0</span>
             </div>

        <canvas id="gameCanvas"></canvas>

        <div id="controls">
            <div class="control-button" id="leftArrow">&lt;</div>
            <div class="control-button" id="pauseButton">Pause</div>
            <div class="control-button" id="shootButton" style="display: none;">FIRE</div>
            <div class="control-button" id="rightArrow">&gt;</div>
        </div>

        <div id="pauseOverlay" class="message-overlay">
            <h2>PAUSED</h2>
            <p>Tap Screen or Press P to Resume</p>
            <p>(Q to Quit - Keyboard Only)</p>
        </div>
         <div id="gameOverOverlay" class="message-overlay">
            <h2>GAME OVER!</h2>
            <p id="finalScore">Final Score: 0</p>
            <p>Tap Screen or Press Key to Restart</p>
        </div>
         <div id="lifeLostOverlay" class="message-overlay">
            <h2 id="lifeLostMessage">Life Lost! X left.</h2>
            <p>Tap Screen or Press Key to Continue</p>
        </div>
    </div>


    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score');
        const levelDisplay = document.getElementById('level');
        const livesDisplay = document.getElementById('lives');
        const leftButton = document.getElementById('leftArrow');
        const rightButton = document.getElementById('rightArrow');
        const pauseButton = document.getElementById('pauseButton');
        const shootButton = document.getElementById('shootButton');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const finalScoreDisplay = document.getElementById('finalScore');
        const lifeLostOverlay = document.getElementById('lifeLostOverlay');
        const lifeLostMessage = document.getElementById('lifeLostMessage');

        // --- Game State ---
        let score = 0;
        let lives = 3;
        let gameLevel = 0;
        let gameOver = false;
        let paused = false;
        let pausedAfterLifeLoss = false;
        let animationFrameId = null;

        // --- Dynamic Sizing ---
        const BASE_WIDTH = 800;
        const BASE_HEIGHT = 600;
        let scaleFactor = 1;
        let canvasWidth = BASE_WIDTH;
        let canvasHeight = BASE_HEIGHT;

        // --- Game Element Properties (Scaled) ---
        let paddle = { x: 0, y: 0, width: 100, baseWidth: 100, widerWidth: 140, height: 15, speed: 8, dx: 0, isWider: false, widerEndTime: 0, hasLaser: false, laserEndTime: 0 };
        let balls = [];
        let bricks = [];
        let powerups = [];
        let lasers = [];

        // --- Constants (Base values, scaled later) ---
        const PADDLE_BASE_WIDTH = 100;
        const PADDLE_WIDER_WIDTH = 140;
        const PADDLE_HEIGHT = 15;
        const PADDLE_Y_OFFSET = 20;
        const PADDLE_SPEED = 10;
        const BALL_RADIUS = 8;
        const BALL_BASE_SPEED_X = 4.5;
        const BALL_BASE_SPEED_Y = -4.5;

        const BRICK_COLS = 10;
        const BRICK_BASE_HEIGHT = 20;
        const BRICK_SPACING_FACTOR = 0.05;
        const BRICK_TOP_OFFSET = 60;
        let BRICK_ROWS_VISIBLE = 12;
        let brickWidth, brickHeight, brickSpacing, brickOffsetY, brickStartX;

        const INITIAL_BRICK_ROWS = 5;
        const GAME_OVER_LINE_Y_FACTOR = 0.9;
        let gameOverLineY;

        // Difficulty/Endless
        const BRICK_SHIFT_INTERVAL_INITIAL = 12000;
        const BRICK_SHIFT_INTERVAL_MIN = 3500;
        let brickShiftAmount;
        let currentBrickShiftInterval = BRICK_SHIFT_INTERVAL_INITIAL;
        let lastBrickShiftTime = 0;
        const DIFFICULTY_SCORE_INTERVAL = 350;
        const MAX_SPEED_MULTIPLIER = 3.0;
        const MAX_BRICK_HITS = 5;
        const DIFFICULTY_SCALING_LEVEL_CAP = 15.0;

        // Powerups / Laser / Bomb
        const POWERUP_CHANCE = 0.18;
        const POWERUP_SPEED_FACTOR = 0.005;
        const POWERUP_SIZE_FACTOR = 0.03;
        let powerupSpeed, powerupSize;
        const POWERUP_DURATION = 7000;
        const LASER_DURATION = 5000;
        const LASER_COOLDOWN = 250;
        const LASER_SPEED_FACTOR = 0.015;
        const LASER_WIDTH_FACTOR = 0.005;
        const LASER_HEIGHT_FACTOR = 0.02;
        let laserSpeed, laserWidth, laserHeight;
        let lastLaserShotTime = 0;
        const BOMB_BRICK_CHANCE = 0.05;
        const BOMB_RADIUS_FACTOR = 1.5;

        // Combo
        const COMBO_RESET_ON_PADDLE = true;
        const COMBO_MULTIPLIER_INCREMENT = 0.1;
        let comboCount = 0;
        let currentComboMultiplier = 1.0;
        let activePowerupType = null;
        let activePowerupTimer = 0;

        // Colors
        const PADDLE_COLOR = '#3C3CC8';
        const BALL_COLOR = '#FFFFFF';
        const BRICK_COLORS = { 1: '#67BBDE', 2: '#323296', 3: '#88D498', 4: '#F29D52', 5: '#D95763', 6: '#8B0000' };
        const BOMB_COLOR = '#808080';
        const LASER_COLOR = '#00FFFF';
        const POWERUP_COLORS = { WIDER: '#88D498', MULTI_BALL: '#9664C8', LASER: '#F29D52' }; // Orange for Laser Powerup

        // --- Input State ---
        let rightPressed = false;
        let leftPressed = false;

        // --- Utility Functions ---
        function scaleValue(baseValue) {
            const sf = typeof scaleFactor === 'number' && isFinite(scaleFactor) ? scaleFactor : 1;
            return baseValue * sf;
        }

        // --- Game Initialization and Resizing ---
        function calculateSizes() {
            const controls = document.getElementById('controls');
            const controlsHeight = controls ? controls.offsetHeight + 30 : 50;
            const availableHeight = Math.max(1, window.innerHeight - controlsHeight);
            const availableWidth = Math.max(1, gameContainer.clientWidth);

            const windowRatio = availableWidth / availableHeight;
            const baseRatio = BASE_WIDTH / BASE_HEIGHT;

            if (windowRatio > baseRatio) {
                canvasHeight = availableHeight;
                canvasWidth = canvasHeight * baseRatio;
            } else {
                canvasWidth = availableWidth;
                canvasHeight = canvasWidth / baseRatio;
            }
             canvasWidth = Math.max(1, Math.floor(canvasWidth));
             canvasHeight = Math.max(1, Math.floor(canvasHeight));

            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            scaleFactor = canvasWidth / BASE_WIDTH;

            // --- Scale game elements ---
            paddle.height = Math.max(1, scaleValue(PADDLE_HEIGHT));
            paddle.baseWidth = Math.max(10, scaleValue(PADDLE_BASE_WIDTH));
            paddle.widerWidth = Math.max(15, scaleValue(PADDLE_WIDER_WIDTH));
            paddle.width = paddle.isWider ? paddle.widerWidth : paddle.baseWidth;
            paddle.y = canvasHeight - paddle.height - scaleValue(PADDLE_Y_OFFSET);
            paddle.speed = Math.max(1, scaleValue(PADDLE_SPEED));

            const scaledBallRadius = Math.max(1, scaleValue(BALL_RADIUS));
            balls.forEach(b => { b.radius = scaledBallRadius; });

            brickHeight = Math.max(1, scaleValue(BRICK_BASE_HEIGHT));
            const approxBrickWidth = canvasWidth > 0 ? canvasWidth / BRICK_COLS : 1;
            const scaledSpacing = Math.max(1, approxBrickWidth * BRICK_SPACING_FACTOR);
            brickWidth = Math.max(1, (canvasWidth - (BRICK_COLS + 1) * scaledSpacing) / BRICK_COLS);
            brickWidth = Math.max(1, brickWidth);
            brickSpacing = Math.max(1, (canvasWidth - BRICK_COLS * brickWidth) / (BRICK_COLS + 1));

            brickOffsetY = scaleValue(BRICK_TOP_OFFSET);
            brickStartX = brickSpacing;
            brickShiftAmount = brickHeight + brickSpacing;
            gameOverLineY = canvasHeight * GAME_OVER_LINE_Y_FACTOR;

            powerupSpeed = Math.max(1, canvasHeight * POWERUP_SPEED_FACTOR);
            powerupSize = Math.max(5, canvasWidth * POWERUP_SIZE_FACTOR);

            laserSpeed = Math.max(1, canvasHeight * LASER_SPEED_FACTOR);
            laserWidth = Math.max(1, canvasWidth * LASER_WIDTH_FACTOR);
            laserHeight = Math.max(2, canvasHeight * LASER_HEIGHT_FACTOR);

            // Adjust font sizes
             const baseFontSize = 16;
             const scaledFontSize = Math.max(10, Math.min(20, baseFontSize * scaleFactor * 1.1));
             const uiSpans = document.querySelectorAll('#ui-info span');
             uiSpans.forEach(span => span.style.fontSize = `${scaledFontSize}px`);

             const overlayBaseSize = 1.5;
             const scaledOverlaySize = Math.max(1, overlayBaseSize * scaleFactor);
             document.querySelectorAll('.message-overlay').forEach(overlay => {
                 overlay.style.fontSize = `${scaledOverlaySize}em`;
             });

            // Recalculate positions
            paddle.x = (canvasWidth - paddle.width) / 2;
            bricks.forEach(brick => {
                 const estCol = Math.floor((brick.x + brick.width/2 - brickStartX) / (brickWidth + brickSpacing));
                 brick.width = brickWidth;
                 brick.height = brickHeight;
                 brick.x = brickStartX + estCol * (brickWidth + brickSpacing);
            });
        }

        function resetBallAndPaddle() {
            paddle.width = paddle.baseWidth;
            paddle.x = (canvasWidth - paddle.width) / 2;
            paddle.y = canvasHeight - paddle.height - scaleValue(PADDLE_Y_OFFSET);
            paddle.isWider = false;
            paddle.hasLaser = false;
            paddle.widerEndTime = 0;
            paddle.laserEndTime = 0;
            activePowerupType = null;
            activePowerupTimer = 0;
            shootButton.style.display = 'none';

            const currentBallRadius = scaleValue(BALL_RADIUS);
            const newBall = {
                 x: paddle.x + paddle.width / 2,
                 y: paddle.y - currentBallRadius - 5,
                 radius: currentBallRadius,
                 baseSpeedX: BALL_BASE_SPEED_X * (Math.random() < 0.5 ? 1 : -1),
                 baseSpeedY: BALL_BASE_SPEED_Y,
                 speedMultiplier: currentSpeedMultiplier,
                 dx: 0, dy: 0
            };
            const magnitude = Math.sqrt(newBall.baseSpeedX**2 + newBall.baseSpeedY**2);
             if (magnitude > 0) {
                 newBall.dx = (newBall.baseSpeedX / magnitude) * Math.abs(BALL_BASE_SPEED_X * newBall.speedMultiplier);
                 newBall.dy = (newBall.baseSpeedY / magnitude) * Math.abs(BALL_BASE_SPEED_Y * newBall.speedMultiplier);
             }
            balls = [newBall];
        }

        function createInitialBricks() {
            bricks = [];
            for (let r = 0; r < INITIAL_BRICK_ROWS; r++) {
                for (let c = 0; c < BRICK_COLS; c++) {
                    if (brickWidth === undefined) calculateSizes(); // Ensure sizes are calculated

                    const brickX = brickStartX + c * (brickWidth + brickSpacing);
                    const brickY = brickOffsetY + r * (brickHeight + brickSpacing);
                    const isBomb = Math.random() < BOMB_BRICK_CHANCE * 0.5;
                    let hits = 1;
                    if (!isBomb) {
                        hits = (r < INITIAL_BRICK_ROWS - 1) ? 2 : 1;
                    }
                    bricks.push({ x: brickX, y: brickY, width: brickWidth, height: brickHeight, visible: true, maxHits: hits, hitsLeft: hits, isBomb: isBomb });
                }
            }
        }

         function generateNewTopRow() {
            const brickY = brickOffsetY - brickShiftAmount;
            for (let c = 0; c < BRICK_COLS; c++) {
                 const brickX = brickStartX + c * (brickWidth + brickSpacing);
                 const isBomb = Math.random() < BOMB_BRICK_CHANCE;
                 let hits = 1;
                 if (!isBomb) {
                     const minHits = 1;
                     const maxHitsForLevel = Math.min(MAX_BRICK_HITS, 1 + Math.floor(gameLevel / 2.0));
                     const hitRoll = Math.random();
                     const difficultyFactor = Math.min(1.0, gameLevel / DIFFICULTY_SCALING_LEVEL_CAP);
                     if (hitRoll < (0.2 + 0.6 * difficultyFactor)) {
                         hits = maxHitsForLevel;
                     } else {
                         const upperRandomBound = Math.max(minHits, maxHitsForLevel - 1);
                         hits = Math.floor(Math.random() * (upperRandomBound - minHits + 1)) + minHits;
                     }
                     hits = Math.max(minHits, hits);
                 }
                 bricks.push({ x: brickX, y: brickY, width: brickWidth, height: brickHeight, visible: true, maxHits: hits, hitsLeft: hits, isBomb: isBomb });
            }
        }

        function shiftBricksDown() {
             let anyBrickTooLow = false;
             bricks.forEach(brick => {
                 brick.y += brickShiftAmount;
                 if (brick.visible && brick.y + brick.height > gameOverLineY) {
                     anyBrickTooLow = true;
                 }
             });

             bricks = bricks.filter(brick => brick.y < canvasHeight);

             if (anyBrickTooLow) {
                 gameOver = true;
             } else {
                 generateNewTopRow();
                 lastBrickShiftTime = performance.now();
             }
        }

         function updateDifficulty() {
            const newLevel = Math.floor(score / DIFFICULTY_SCORE_INTERVAL);
            if (newLevel > gameLevel) {
                gameLevel = newLevel;
                const fraction = Math.min(1.0, gameLevel / DIFFICULTY_SCALING_LEVEL_CAP);

                currentSpeedMultiplier = 1.0 + (MAX_SPEED_MULTIPLIER - 1.0) * fraction;
                balls.forEach(b => {
                    b.speedMultiplier = currentSpeedMultiplier;
                    const magnitude = Math.sqrt(b.baseSpeedX**2 + b.baseSpeedY**2);
                    if (magnitude > 0) {
                        b.dx = (b.baseSpeedX / magnitude) * Math.abs(BALL_BASE_SPEED_X * b.speedMultiplier);
                        b.dy = (b.baseSpeedY / magnitude) * Math.abs(BALL_BASE_SPEED_Y * b.speedMultiplier);
                    }
                });

                const intervalReduction = (BRICK_SHIFT_INTERVAL_INITIAL - BRICK_SHIFT_INTERVAL_MIN) * fraction;
                currentBrickShiftInterval = BRICK_SHIFT_INTERVAL_INITIAL - intervalReduction;
                currentBrickShiftInterval = Math.max(currentBrickShiftInterval, BRICK_SHIFT_INTERVAL_MIN);
            }
        }

        function triggerBombExplosion(centerX, centerY) {
            const explosionRadiusSq = Math.pow(brickWidth * BOMB_RADIUS_FACTOR, 2);
            let bricksDestroyedByBomb = 0;

            bricks.forEach(brick => {
                if (brick.visible && !brick.isBomb) {
                    const brickCenterX = brick.x + brick.width / 2;
                    const brickCenterY = brick.y + brick.height / 2;
                    const dx = brickCenterX - centerX;
                    const dy = brickCenterY - centerY;
                    const distSq = dx * dx + dy * dy;

                    if (distSq <= explosionRadiusSq) {
                        if (brick.hitsLeft > 0) {
                            const pointsEarned = Math.floor(10 * brick.maxHits * currentComboMultiplier);
                            score += pointsEarned;
                            brick.visible = false;
                            brick.hitsLeft = 0;
                            bricksDestroyedByBomb++;
                        }
                    }
                }
            });

             if (bricksDestroyedByBomb > 0) {
                comboCount += bricksDestroyedByBomb;
                currentComboMultiplier += COMBO_MULTIPLIER_INCREMENT * bricksDestroyedByBomb;
                // Play break sound
            }
        }

        function initializeGame() {
            // console.log("--- Initializing Game ---"); // Debug log
            score = 0;
            lives = 3;
            gameLevel = 0;
            gameOver = false;
            paused = false;
            pausedAfterLifeLoss = false;
            comboCount = 0;
            currentComboMultiplier = 1.0;
            currentSpeedMultiplier = 1.0;
            currentBrickShiftInterval = BRICK_SHIFT_INTERVAL_INITIAL;
            activePowerupType = null;
            activePowerupTimer = 0;
            powerups = [];
            lasers = [];

            calculateSizes();
            createInitialBricks();
            resetBallAndPaddle();

            lastBrickShiftTime = performance.now();

            pauseOverlay.style.display = 'none';
            gameOverOverlay.style.display = 'none';
            lifeLostOverlay.style.display = 'none';

            if (animationFrameId !== null) {
                 cancelAnimationFrame(animationFrameId);
            }
            gameLoop();
            // console.log("--- Initialization Complete --- Lives:", lives); // Debug log
        }


        // --- Drawing Functions ---
        function drawPaddle() {
            // FIX: Use defined color constant
            ctx.fillStyle = paddle.hasLaser ? POWERUP_COLORS.LASER : PADDLE_COLOR;
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
        }

        function drawBall(b) {
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
            ctx.fillStyle = BALL_COLOR;
            ctx.fill();
        }

        function drawBricks() {
            bricks.forEach(brick => {
                if (brick.visible) {
                    let color = BRICK_COLORS[1] || '#67BBDE'; // Default color fix
                    if (brick.isBomb) {
                        color = BOMB_COLOR;
                    } else {
                         const colorKeys = Object.keys(BRICK_COLORS).map(Number);
                         const validColorKeys = colorKeys.filter(k => !isNaN(k));
                         const maxColorKey = validColorKeys.length > 0 ? Math.max(...validColorKeys) : 1;
                         const colorKey = Math.min(brick.hitsLeft, maxColorKey);
                         color = BRICK_COLORS[colorKey] || BRICK_COLORS[maxColorKey] || '#67BBDE';
                    }
                    ctx.fillStyle = color;
                    ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);

                    if (brick.isBomb) {
                         ctx.fillStyle = '#000000';
                         ctx.font = `${Math.max(8, brickHeight * 0.6)}px Arial`;
                         ctx.textAlign = 'center';
                         ctx.textBaseline = 'middle';
                         ctx.fillText('B', brick.x + brick.width / 2, brick.y + brick.height / 2);
                    }
                }
            });
        }


        function drawPowerups() {
             powerups.forEach(p => {
                 if (p.visible) {
                     let color = '#FF0000', letter = '?';
                     if (p.type === 'WIDER') { color = POWERUP_COLORS.WIDER; letter = 'W'; }
                     else if (p.type === 'MULTI_BALL') { color = POWERUP_COLORS.MULTI_BALL; letter = 'M'; }
                     else if (p.type === 'LASER') { color = POWERUP_COLORS.LASER; letter = 'L'; }

                     ctx.fillStyle = color;
                     ctx.fillRect(p.x, p.y, p.size, p.size);
                     ctx.fillStyle = '#FFFFFF';
                     ctx.font = `bold ${Math.max(8, p.size * 0.7)}px Arial`;
                     ctx.textAlign = 'center';
                     ctx.textBaseline = 'middle';
                     ctx.fillText(letter, p.x + p.size / 2, p.y + p.size / 2 + 1);
                 }
             });
        }

        function drawLasers() {
             lasers.forEach(l => {
                 if (l.visible) {
                     ctx.fillStyle = LASER_COLOR;
                     ctx.fillRect(l.x, l.y, l.width, l.height);
                 }
             });
        }

        function drawUI() {
            scoreDisplay.textContent = `Score: ${score}`;
            levelDisplay.textContent = `Level: ${gameLevel}`;
            livesDisplay.textContent = `Lives: ${lives}`;
        }

        // --- Update Functions ---
        function movePaddle() {
            if (rightPressed) {
                paddle.x += paddle.speed;
            } else if (leftPressed) {
                paddle.x -= paddle.speed;
            }
            paddle.x = Math.max(0, Math.min(canvasWidth - paddle.width, paddle.x));
        }

        function moveBall(b) {
            b.x += b.dx;
            b.y += b.dy;

            if (b.x + b.radius > canvasWidth || b.x - b.radius < 0) {
                b.baseSpeedX *= -1;
                const magnitude = Math.sqrt(b.baseSpeedX**2 + b.baseSpeedY**2);
                 if (magnitude > 0) { b.dx = (b.baseSpeedX / magnitude) * Math.abs(BALL_BASE_SPEED_X * b.speedMultiplier); }
                b.x = (b.x - b.radius < 0) ? b.radius : canvasWidth - b.radius;
            }
            if (b.y - b.radius < 0) {
                b.baseSpeedY *= -1;
                const magnitude = Math.sqrt(b.baseSpeedX**2 + b.baseSpeedY**2);
                 if (magnitude > 0) { b.dy = (b.baseSpeedY / magnitude) * Math.abs(BALL_BASE_SPEED_Y * b.speedMultiplier); }
                b.y = b.radius;
            }
        }

        function handleCollisions() {
            const now = performance.now();

            // Ball vs Paddle
            balls.forEach(b => {
                if (b.dy > 0 &&
                    b.x > paddle.x - b.radius &&
                    b.x < paddle.x + paddle.width + b.radius &&
                    b.y + b.radius > paddle.y &&
                    b.y - b.radius < paddle.y + paddle.height)
                {
                    if (b.x + b.radius > paddle.x && b.x - b.radius < paddle.x + paddle.width) {
                        const hitOffset = (b.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
                        b.baseSpeedY *= -1;
                        b.baseSpeedX += hitOffset * BALL_BASE_SPEED_X * 1.2;
                        const maxBaseX = BALL_BASE_SPEED_X * 2.0;
                        b.baseSpeedX = Math.max(-maxBaseX, Math.min(maxBaseX, b.baseSpeedX));

                        const magnitude = Math.sqrt(b.baseSpeedX**2 + b.baseSpeedY**2);
                        if (magnitude > 0) {
                            b.dx = (b.baseSpeedX / magnitude) * Math.abs(BALL_BASE_SPEED_X * b.speedMultiplier);
                            b.dy = (b.baseSpeedY / magnitude) * Math.abs(BALL_BASE_SPEED_Y * b.speedMultiplier);
                        }
                        b.y = paddle.y - b.radius;

                        if (COMBO_RESET_ON_PADDLE) { comboCount = 0; currentComboMultiplier = 1.0; }
                    }
                }
            });

            // Ball vs Bricks
            balls.forEach(b => {
                 let bouncedThisFrame = false;
                 bricks.forEach(brick => {
                     if (!bouncedThisFrame && brick.visible &&
                         b.x + b.radius > brick.x && b.x - b.radius < brick.x + brick.width &&
                         b.y + b.radius > brick.y && b.y - b.radius < brick.y + brick.height)
                    {
                         b.baseSpeedY *= -1;
                         const magnitude = Math.sqrt(b.baseSpeedX**2 + b.baseSpeedY**2);
                         if (magnitude > 0) { b.dy = (b.baseSpeedY / magnitude) * Math.abs(BALL_BASE_SPEED_Y * b.speedMultiplier); }

                         if (b.dy > 0) { b.y = brick.y + brick.height + b.radius + 0.1; }
                         else { b.y = brick.y - b.radius - 0.1; }

                         brick.hitsLeft--;
                         if (brick.hitsLeft <= 0) {
                             brick.visible = false;
                             const pointsEarned = Math.floor(10 * brick.maxHits * currentComboMultiplier);
                             score += pointsEarned;
                             comboCount++;
                             currentComboMultiplier += COMBO_MULTIPLIER_INCREMENT;

                             if (brick.isBomb) {
                                 triggerBombExplosion(brick.x + brick.width / 2, brick.y + brick.height / 2);
                             } else {
                                if (Math.random() < POWERUP_CHANCE) {
                                    const type = ['WIDER', 'MULTI_BALL', 'LASER'][Math.floor(Math.random() * 3)];
                                    powerups.push({ x: brick.x + brick.width / 2 - powerupSize / 2, y: brick.y + brick.height / 2, size: powerupSize, speed: powerupSpeed, type: type, visible: true });
                                }
                             }
                         } else { /* Play hit sound */ }
                         bouncedThisFrame = true;
                     }
                 });
            });

             // Laser vs Bricks
             lasers.forEach(l => {
                 if (!l.visible) return;
                 bricks.forEach(brick => {
                     if (brick.visible && l.x < brick.x + brick.width && l.x + l.width > brick.x && l.y < brick.y + brick.height && l.y + l.height > brick.y) {
                         l.visible = false;
                         brick.hitsLeft--;
                         if (brick.hitsLeft <= 0) {
                             brick.visible = false;
                             const pointsEarned = Math.floor(10 * brick.maxHits * currentComboMultiplier);
                             score += pointsEarned;
                             comboCount++;
                             currentComboMultiplier += COMBO_MULTIPLIER_INCREMENT;
                             if (brick.isBomb) { triggerBombExplosion(brick.x + brick.width / 2, brick.y + brick.height / 2); }
                         } else { /* Play hit sound */ }
                         return;
                     }
                 });
             });

             // Powerup vs Paddle
             powerups.forEach(p => {
                 if (p.visible && p.x < paddle.x + paddle.width && p.x + p.size > paddle.x && p.y < paddle.y + paddle.height && p.y + p.size > paddle.y) {
                     p.visible = false;
                     if (p.type === 'WIDER') {
                         if (!paddle.isWider) { paddle.x -= (paddle.widerWidth - paddle.baseWidth) / 2; }
                         paddle.isWider = true; paddle.width = paddle.widerWidth;
                         paddle.widerEndTime = now + POWERUP_DURATION;
                     } else if (p.type === 'MULTI_BALL') {
                         const baseBall = balls[0] || { x: paddle.x + paddle.width/2, y: paddle.y - 20, speedMultiplier: currentSpeedMultiplier};
                         for (let i = 0; i < 2; i++) {
                             const nb = { x: baseBall.x + (Math.random() - 0.5) * 20, y: baseBall.y, radius: scaleValue(BALL_RADIUS), baseSpeedX: BALL_BASE_SPEED_X * (Math.random() < 0.5 ? 1 : -1) * (0.8 + Math.random()*0.4), baseSpeedY: BALL_BASE_SPEED_Y * (0.8 + Math.random()*0.4), speedMultiplier: baseBall.speedMultiplier, dx: 0, dy: 0 };
                             const mag = Math.sqrt(nb.baseSpeedX**2 + nb.baseSpeedY**2);
                             if (mag > 0) { nb.dx = (nb.baseSpeedX / mag) * Math.abs(BALL_BASE_SPEED_X * nb.speedMultiplier); nb.dy = (nb.baseSpeedY / mag) * Math.abs(BALL_BASE_SPEED_Y * nb.speedMultiplier); }
                             balls.push(nb);
                         }
                     } else if (p.type === 'LASER') {
                          paddle.hasLaser = true;
                          paddle.laserEndTime = now + LASER_DURATION;
                          shootButton.style.display = 'block';
                     }
                     updatePaddleState(); // Update indicator immediately
                 }
             });
        }

        function updatePaddleState() {
            const now = performance.now();
            let wasWider = paddle.isWider;

            if (paddle.isWider && now >= paddle.widerEndTime) {
                paddle.isWider = false;
                paddle.width = paddle.baseWidth;
                 if (wasWider) paddle.x += (paddle.widerWidth - paddle.baseWidth) / 2;
            }

            if (paddle.hasLaser && now >= paddle.laserEndTime) {
                paddle.hasLaser = false;
                 shootButton.style.display = 'none';
            } else if (paddle.hasLaser) {
                 shootButton.style.display = 'block';
            } else {
                 shootButton.style.display = 'none';
            }

             let currentActiveType = null;
             let currentEndTime = 0;
             if (paddle.isWider && paddle.widerEndTime > currentEndTime) {
                 currentActiveType = 'WIDE';
                 currentEndTime = paddle.widerEndTime;
             }
             if (paddle.hasLaser && paddle.laserEndTime > currentEndTime) {
                 currentActiveType = 'LASER';
                 currentEndTime = paddle.laserEndTime;
             }
             activePowerupType = currentActiveType;
             activePowerupTimer = currentEndTime;
        }


        function updateLasers() {
             lasers.forEach(l => l.move());
             lasers = lasers.filter(l => l.visible && l.y > -l.height);
        }

        function updatePowerups() {
             powerups.forEach(p => {
                 if (p.visible) {
                     // Directly update position here instead of calling p.move()
                     p.y += p.speed;
                     // Check if off-screen after moving and mark for removal
                     if (p.y > canvasHeight) {
                         p.visible = false;
                     }
                 }
             });
             // Filter remains the same, removing non-visible powerups
             powerups = powerups.filter(p => p.visible);
        }


        // --- Game Loop ---
        function gameLoop(timestamp) {
            if (gameOver) {
                gameOverOverlay.style.display = 'flex';
                finalScoreDisplay.textContent = `Final Score: ${score}`;
                if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
                return;
            }
             if (paused) {
                 pauseOverlay.style.display = 'flex';
                 animationFrameId = requestAnimationFrame(gameLoop);
                 return;
             }
             if (pausedAfterLifeLoss) {
                 lifeLostOverlay.style.display = 'flex';
                 lifeLostMessage.textContent = `Life Lost! ${lives} left.`;
                 animationFrameId = requestAnimationFrame(gameLoop);
                 return;
             }

            pauseOverlay.style.display = 'none';
            gameOverOverlay.style.display = 'none';
            lifeLostOverlay.style.display = 'none';

            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // --- Logic ---
            updateDifficulty();
            movePaddle();
            balls.forEach(moveBall);
            updatePaddleState();
            updateLasers();
            updatePowerups(); // Now correctly updates powerup positions
            handleCollisions();

             // Check Ball Loss
             const ballsLostThisFrame = balls.filter(b => b.y - b.radius > canvasHeight);
             if (ballsLostThisFrame.length > 0) {
                 balls = balls.filter(b => b.y - b.radius <= canvasHeight);
                 if (balls.length === 0) {
                     // console.log("Last ball lost. Lives before:", lives); // Debug log
                     lives--;
                     // console.log("Lives after:", lives); // Debug log
                     comboCount = 0; currentComboMultiplier = 1.0;
                     // Don't reset paddle position immediately, wait for resume
                     activePowerupType = null; activePowerupTimer = 0; shootButton.style.display = 'none';

                     if (lives <= 0) {
                         // console.log("Lives reached 0. Setting gameOver = true"); // Debug log
                         gameOver = true;
                         add_high_score(score);
                     } else {
                         pausedAfterLifeLoss = true;
                         // console.log("Paused for life loss. pausedAfterLifeLoss =", pausedAfterLifeLoss); // Debug log
                     }
                 }
             }

             // Check Brick Shift
             if (!gameOver && performance.now() - lastBrickShiftTime >= currentBrickShiftInterval) {
                 shiftBricksDown();
                 if (gameOver) {
                    add_high_score(score);
                    gameOverOverlay.style.display = 'flex';
                    finalScoreDisplay.textContent = `Final Score: ${score}`;
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                    return;
                 }
             }

            // --- Drawing ---
            drawBricks();
            drawPaddle();
            drawPowerups();
            drawLasers();
            balls.forEach(drawBall);
            drawUI();

            // --- Request Next Frame ---
            if (!gameOver) {
                animationFrameId = requestAnimationFrame(gameLoop);
            } else {
                 gameOverOverlay.style.display = 'flex';
                 finalScoreDisplay.textContent = `Final Score: ${score}`;
                 if (animationFrameId) cancelAnimationFrame(animationFrameId);
                 animationFrameId = null;
            }
        }

        // --- Placeholder High Score Logic ---
         let highScores = [];
         function add_high_score(score) {
             // console.log("Adding score:", score); // Debug log
             highScores.push(score);
             highScores.sort((a, b) => b - a);
             highScores = highScores.slice(0, 5);
             save_high_scores();
             // console.log("High Scores:", highScores); // Debug log
         }
         function load_high_scores() {
             const storedScores = localStorage.getItem('breakoutHighScores');
             if (storedScores) {
                 try {
                     highScores = JSON.parse(storedScores);
                     highScores.sort((a, b) => b - a);
                 } catch (e) { highScores = []; }
             } else { highScores = []; }
             // console.log("Loaded High Scores:", highScores); // Debug log
         }
          function save_high_scores() {
             try {
                 localStorage.setItem('breakoutHighScores', JSON.stringify(highScores));
             } catch (e) { console.error("Failed to save high scores:", e); }
         }


        // --- Event Listeners ---
        function handleKeyDown(e) {
            // console.log("Key Down:", e.key, "gameOver:", gameOver, "pausedAfterLifeLoss:", pausedAfterLifeLoss, "paused:", paused); // Debug log
            if (gameOver) { initializeGame(); return; }
            if (pausedAfterLifeLoss) {
                // console.log("Resuming after life loss via keyboard."); // Debug log
                pausedAfterLifeLoss = false;
                resetBallAndPaddle(); // Respawn ball now
                return; // Important: return after handling this state
            }
            if (e.key === 'p' || e.key === 'P') {
                paused = !paused;
                // console.log("Paused toggled via key:", paused); // Debug log
                 if (paused) pauseButton.classList.add('active');
                 else pauseButton.classList.remove('active');
                 return; // Return after handling pause toggle
            }
            if (paused) {
                if (e.key === 'q' || e.key === 'Q') {
                     if (animationFrameId) cancelAnimationFrame(animationFrameId);
                     alert("Game Quit. Refresh.");
                 }
                 return; // Ignore gameplay keys if paused
            }

            // Handle gameplay keys only if not paused
            if (e.key === 'Right' || e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') rightPressed = true;
            else if (e.key === 'Left' || e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') leftPressed = true;
            else if (e.key === ' ') fireLaser();
        }

        function handleKeyUp(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') rightPressed = false;
            else if (e.key === 'Left' || e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') leftPressed = false;
        }

         function fireLaser() {
             const now = performance.now();
             if (!paused && !gameOver && !pausedAfterLifeLoss && paddle.hasLaser && now - lastLaserShotTime >= LASER_COOLDOWN) {
                 const laserXOffset = scaleValue(5);
                 lasers.push({ x: paddle.x + laserXOffset, y: paddle.y, width: laserWidth, height: laserHeight, speed: laserSpeed, visible: true });
                 lasers.push({ x: paddle.x + paddle.width - laserXOffset - laserWidth, y: paddle.y, width: laserWidth, height: laserHeight, speed: laserSpeed, visible: true });
                 lastLaserShotTime = now;
                 // Play sound
             }
         }

        // Touch/Pointer Controls
        function handlePointerDown(e) {
            e.preventDefault();
            const target = e.target;
            // console.log("Pointer Down Target:", target.id); // Debug log

            if (gameOver) { initializeGame(); return; }
            if (pausedAfterLifeLoss) {
                 // console.log("Resuming after life loss via touch/click."); // Debug log
                 pausedAfterLifeLoss = false;
                 resetBallAndPaddle(); // Respawn ball now
                 return;
            }
            // Allow pause button or overlay interaction when paused
            if (paused) {
                 if (target === pauseButton || target === pauseOverlay) {
                     paused = false;
                     pauseButton.classList.remove('active'); // Ensure button state matches
                     // console.log("Unpaused via touch/click"); // Debug log
                 }
                 return; // Ignore other inputs when paused
            }

            // Handle gameplay buttons only if not paused
            if (target === leftButton) { leftPressed = true; target.classList.add('active'); }
            else if (target === rightButton) { rightPressed = true; target.classList.add('active'); }
            else if (target === pauseButton) { // Pause the game
                 paused = true;
                 target.classList.add('active'); // Show button as active while paused
                 // console.log("Paused via touch/click"); // Debug log
            }
            else if (target === shootButton && paddle.hasLaser) { fireLaser(); target.classList.add('active'); }
        }

        function handlePointerUpOrCancel(e) {
            e.preventDefault();
            // console.log("Pointer Up/Cancel"); // Debug log
            leftPressed = false;
            rightPressed = false;
            leftButton.classList.remove('active');
            rightButton.classList.remove('active');
            shootButton.classList.remove('active');
            // Don't change pause button state here, only on toggle
        }

        // Window Resize
        function handleResize() {
            // console.log("Window resized"); // Less verbose
            if (animationFrameId !== null) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            calculateSizes();

             if (!paused && !gameOver && !pausedAfterLifeLoss) {
                 animationFrameId = requestAnimationFrame(gameLoop);
             } else {
                  ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                  drawBricks();
                  drawPaddle();
                  drawPowerups();
                  drawLasers();
                  balls.forEach(drawBall);
                  drawUI();
                  if (paused) pauseOverlay.style.display = 'flex';
                  if (pausedAfterLifeLoss) lifeLostOverlay.style.display = 'flex';
                  if (gameOver) {
                      gameOverOverlay.style.display = 'flex';
                      finalScoreDisplay.textContent = `Final Score: ${score}`;
                  }
             }
        }

        // --- Start ---
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        window.addEventListener('resize', handleResize);

        [leftButton, rightButton, pauseButton, shootButton, gameOverOverlay, lifeLostOverlay, pauseOverlay].forEach(element => {
             if (element) {
                 element.addEventListener('pointerdown', handlePointerDown, { passive: false });
                 if (element.classList.contains('control-button')) {
                     element.addEventListener('pointerup', handlePointerUpOrCancel, { passive: false });
                     element.addEventListener('pointercancel', handlePointerUpOrCancel, { passive: false });
                     element.addEventListener('pointerleave', handlePointerUpOrCancel, { passive: false });
                 }
             }
        });

        // --- Initial Load ---
        load_high_scores();
        initializeGame();

    </script>
</body>
</html>
